================================================================================
                    AI SUPPORT TICKETING SYSTEM - PROJECT OVERVIEW
================================================================================

This document provides a comprehensive 1000-word overview covering backend APIs, 
database schema, frontend implementation, testing infrastructure, and configuration.

================================================================================
                            BACKEND (FASTAPI)
================================================================================

The backend is built using FastAPI v0.119.0, providing automatic API documentation, 
async support, and Pydantic validation. Main file: main.py runs on Uvicorn.

API ENDPOINTS:
1. GET / - Health check
2. POST /ticket - Create/continue ticket with AI reply
3. POST /ticket/{ticket_id}/reply - Add message and generate AI reply
4. GET /ticket/{ticket_id} - Fetch complete ticket thread
5. GET /stats - Ticket statistics (total, open, closed)
6. GET /admin/tickets?status= - List tickets with filtering
7. POST /admin/ticket/{ticket_id}/assign?agent_name= - Assign human agent
8. POST /admin/ticket/{ticket_id}/close - Close ticket (requires admin token)

KEY FEATURES:
Rate Limiting: Configurable window-based limits for AI replies per ticket (default: 
2 replies per 60 seconds). Output Sanitization: Automatic redaction of profanity 
(using regex: \b(fuck|shit|bitch|asshole)(?:ing|s|ed)?\b), emails, phone numbers, 
and credit card numbers in AI responses. Retry Logic: Exponential backoff for OpenAI 
API calls (3 retries, 0.5s initial delay, 2x multiplier). Human Escalation: 
Automatically skips AI replies when human agent is assigned. Ticket Continuity: 
Finds existing open tickets matching context+subject to maintain conversation threads.

CONFIGURATION (config.py): Type-safe Pydantic Settings with environment variable 
loading from .env. Required: OPENAI_API_KEY, SUPABASE_URL, SUPABASE_KEY. Optional: 
ADMIN_TOKEN, rate limits, retry settings, logging levels. Validates on startup and 
fails fast if missing required variables.

LOGGING (logger.py): Structured logging with format: timestamp, level, filename, 
line number, message. Configurable via LOG_LEVEL environment variable.

ERROR HANDLING (middleware.py): Global exception handler, HTTP exception handler, 
validation exception handler. Returns standardized JSON error responses with 
appropriate status codes.

SUPABASE INTEGRATION (supabase_config.py): Creates Supabase client, validates 
credentials, returns None if invalid for graceful degradation.

================================================================================
                            DATABASE (SUPABASE/POSTGRESQL)
================================================================================

TICKETS TABLE:
- id (uuid, primary key)
- context (text) - Customer/brand (e.g., "acme")
- subject (text) - Ticket subject
- status (text) - "open", "human_assigned", "closed"
- assigned_to (text, nullable) - Human agent name
- created_at, updated_at (timestamptz)

Indexes: tickets(status), tickets(context, subject, status)

MESSAGES TABLE:
- id (uuid, primary key)
- ticket_id (uuid, foreign key → tickets.id, cascade delete)
- sender (text) - "customer" or "ai"
- message (text) - Message content
- confidence (numeric, nullable) - AI confidence score
- success (boolean, nullable) - AI generation flag
- created_at (timestamptz)

Index: messages(ticket_id)

VIEWS: ticket_summary - Aggregated metrics per ticket

================================================================================
                          FRONTEND (REACT + VITE + TAILWIND)
================================================================================

TECHNOLOGY: React 19.1.1, Vite 7.1.7, Tailwind CSS 4.1.16, Context API for state.

ARCHITECTURE:
State Management (contexts/AppContext.jsx): Global state via React Context. Manages: 
tickets list, current ticket, thread data, filters, base URL, loading/error states. 
Functions: loadTickets(), loadThread(), openTicket(), updateStatusFilter(), 
updateBaseUrl().

COMPONENTS:
1. Layout.jsx - Two-column grid (sidebar + main content)
2. TicketList.jsx - Sidebar with filtered tickets, status badges, search controls
3. TicketThread.jsx - Conversation view with message history and reply input
4. MessageBubble.jsx - Individual message display with sender, timestamp
5. NewTicketForm.jsx - Form for creating tickets (context, subject inputs)
6. AdminPanel.jsx - Admin controls (assign agent, close ticket)
7. Loading.jsx - Reusable loading spinner

API SERVICE (services/api.js): Centralized API client. Functions: createTicket(), 
sendReply(), getTicketThread(), getTickets(), getStats(), assignAgent(), 
closeTicket(). Automatic error handling, base URL/Admin token in localStorage.

STYLING: Bright white theme with orange (#ff6b35) and blue (#0f149a) accents. 
Tailwind CSS with custom colors, gradients, smooth animations (fade-in, slide-up, 
scale-in, pulse). Hover effects with lift animations and shadow transitions. 
Gradient buttons with interactive states. Responsive design with consistent typography.

================================================================================
                            TESTING (PYTEST)
================================================================================

FRAMEWORK: pytest 8.3.4 with pytest-asyncio, pytest-cov, pytest-mock.

TEST STRUCTURE (tests/):
- conftest.py - Fixtures: app_client (FastAPI test client), mock_supabase_client 
  (mocked with chainable methods), mock_openai_client, sample_ticket_request
- test_api.py - Integration tests for all 8 API endpoints
- test_helpers.py - Unit tests for sanitize_output(), is_rate_limited(), 
  generate_ai_reply()

COVERAGE: Health check, ticket creation (new/existing), message replies, rate 
limiting, output sanitization (profanity/PII), admin endpoints, error handling.

================================================================================
                          SECURITY & RELIABILITY
================================================================================

SECURITY: PII redaction (emails, phones, credit cards). Profanity filtering via 
regex. Optional admin token protection. CORS properly configured.

RELIABILITY: Rate limiting (window-based). Retry logic (exponential backoff). 
Centralized error handling with logging. Graceful degradation (missing Supabase). 
Pydantic validation ensures type safety.

================================================================================
                          DEPLOYMENT CONFIGURATION
================================================================================

ENVIRONMENT VARIABLES (.env):
Required: OPENAI_API_KEY, SUPABASE_URL, SUPABASE_KEY
Optional: ADMIN_TOKEN, AI_REPLY_WINDOW_SECONDS (default: 60), 
AI_REPLY_MAX_PER_WINDOW (default: 2), LOG_LEVEL (default: INFO), 
OPENAI_MAX_RETRIES (default: 3), OPENAI_INITIAL_DELAY (default: 0.5), 
OPENAI_BACKOFF_MULTIPLIER (default: 2.0)

RUNNING:
Backend: uvicorn main:app --reload (http://localhost:8000)
Frontend: npm run dev (http://localhost:3000)
Tests: pytest (with coverage: pytest --cov)

DEPENDENCIES:
Backend: fastapi, uvicorn, pydantic, openai, supabase, pytest suite, python-dotenv
Frontend: react, react-dom, vite, tailwindcss, @tailwindcss/postcss

================================================================================
                            KEY WORKFLOWS
================================================================================

TICKET CREATION: Customer submits context/subject/message → System checks for 
existing open ticket → Creates or continues ticket → Stores customer message → 
If no human assigned: rate limit check → OpenAI generation → Sanitize output → 
Store AI reply → Return to client.

TICKET REPLY: Customer sends follow-up → Verify ticket exists → Store message → 
If human assigned: skip AI → Otherwise: generate AI reply with full context → 
Rate limit + sanitization → Return updated thread.

ADMIN: Assign Agent (update status to "human_assigned", set assigned_to), Close 
Ticket (update status to "closed"), List Tickets (retrieve with optional filtering).

================================================================================
                            PROJECT STATISTICS
================================================================================

Code: Backend (6 Python files), Frontend (8 components + contexts + services), 
Tests (2 test files). Total: ~2000+ lines.

APIs: 8 endpoints (1 health, 4 public, 3 admin). Database: 2 tables + 1 view. 
Components: 7 React components.

TECHNICAL HIGHLIGHTS: 
Type-Safe Configuration: Pydantic Settings validates all config at startup. 
Structured Logging: Comprehensive logging with context and error tracking. 
Modern React: Latest patterns with Context API and functional components. 
Tailwind v4: Latest CSS framework with CSS-based configuration. Comprehensive 
Testing: Full test suite with mocks for external dependencies. Production-Ready: 
Error handling, rate limiting, retry logic, and sanitization built-in. Developer 
Experience: Hot reload, automatic API docs (/docs endpoint), clear error messages. 
Scalable Architecture: Separation of concerns, modular components, clean abstractions.

FRONTEND-BACKEND INTEGRATION:
Frontend runs on http://localhost:3000, backend on http://localhost:8000. Vite 
proxy configured for /api routes. All API calls use fetch with automatic error 
handling. Base URL and admin token stored in browser localStorage for persistence.

DATA FLOW:
Customer creates ticket via frontend form → POST /ticket → Backend checks 
existing ticket → Creates/continues ticket → Stores customer message → Generates 
AI reply (if no human assigned) → Sanitizes output → Returns ticket_id + reply → 
Frontend displays in thread view. Subsequent messages follow same flow via 
POST /ticket/{ticket_id}/reply endpoint.

SECURITY MEASURES:
All AI-generated text sanitized before storage/display. Profanity filtered via 
regex patterns. PII (emails, phones, credit cards) automatically redacted. Admin 
endpoints protected by optional token authentication. CORS allows frontend origin. 
Rate limiting prevents API abuse and spam. Retry logic prevents failures from 
temporary network issues.

================================================================================
